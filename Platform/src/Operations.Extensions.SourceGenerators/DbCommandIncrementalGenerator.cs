using Microsoft.CodeAnalysis;
using System.Collections.Immutable;
using System.Text;

namespace Operations.Extensions.SourceGenerators;

[Generator]
public class DbCommandIncrementalGenerator : IIncrementalGenerator
{
    private const string DbCommandAttributeName = "Operations.Extensions.Dapper.DbCommandAttribute";
    private const string UseSpProperty = "build_property.OperationsDbUseStoredProcedures";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var defaultUseSpProvider = context.AnalyzerConfigOptionsProvider
            .Select(static (p, _) => !p.GlobalOptions.TryGetValue(UseSpProperty, out var v) || !string.Equals(v, "false", System.StringComparison.OrdinalIgnoreCase));

        var commands = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                DbCommandAttributeName,
                static (_, _) => true,
                static (ctx, _) => (Symbol: (INamedTypeSymbol)ctx.TargetSymbol, Attribute: ctx.Attributes[0]))
            .Combine(defaultUseSpProvider)
            .Select(static (pair, _) => ExtractInfo(pair.Left.Symbol, pair.Left.Attribute, pair.Right))
            .Where(static info => info is not null);

        context.RegisterSourceOutput(commands, static (spc, info) =>
        {
            if (info.HasValue)
                GenerateSource(spc, info.Value);
        });
    }

    private static CommandInfo? ExtractInfo(INamedTypeSymbol typeSymbol, AttributeData attr, bool defaultUseSp)
    {
        if (attr.ConstructorArguments.Length == 0)
            return null;

        var cmdText = attr.ConstructorArguments[0].Value as string ?? string.Empty;

        bool? specifiedUseSp = null;
        if (attr.ConstructorArguments.Length > 1 && attr.ConstructorArguments[1].Value is bool b)
            specifiedUseSp = b;

        var useSp = specifiedUseSp ?? defaultUseSp;

        var containing = ImmutableArray.CreateBuilder<string>();
        var parent = typeSymbol.ContainingType;
        while (parent is not null)
        {
            containing.Add(GetTypeDeclaration(parent));
            parent = parent.ContainingType;
        }
        if (containing.Count > 0)
            containing.Reverse();

        return new CommandInfo(
            Namespace: typeSymbol.ContainingNamespace.IsGlobalNamespace ? null : typeSymbol.ContainingNamespace.ToDisplayString(),
            ContainingTypes: containing.ToImmutable(),
            CommandTypeFullName: typeSymbol.ToDisplayString(),
            CommandText: cmdText,
            UseStoredProcedure: useSp);
    }

    private static void GenerateSource(SourceProductionContext context, CommandInfo info)
    {
        var source = BuildSourceCode(info);
        var fileName = GetSafeFileName(info.CommandTypeFullName);
        context.AddSource($"{fileName}.DbCommand.g.cs", source);
    }

    private static string BuildSourceCode(CommandInfo info)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (info.Namespace is not null)
        {
            sb.AppendLine($"namespace {info.Namespace};");
            sb.AppendLine();
        }

        foreach (var ct in info.ContainingTypes)
        {
            sb.AppendLine(ct);
            sb.AppendLine("{");
        }

        sb.AppendLine($"    public static async global::System.Threading.Tasks.Task<int> Handle({info.CommandTypeFullName} command, global::Npgsql.NpgsqlDataSource dataSource, global::System.Threading.CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        if (info.UseStoredProcedure)
        {
            sb.AppendLine($"        return await global::Operations.Extensions.Dapper.NpgsqlDataSourceExtensions.CallSp(dataSource, \"{info.CommandText}\", command, cancellationToken);");
        }
        else
        {
            sb.AppendLine("        await using var connection = await dataSource.OpenConnectionAsync(cancellationToken);");
            sb.AppendLine("        var parameters = ((global::Operations.Extensions.Dapper.IDbParamsProvider)command).ToDbParams();");
            sb.AppendLine($"        return await connection.ExecuteAsync(\"{info.CommandText}\", parameters);");
        }
        sb.AppendLine("    }");

        for (var i = 0; i < info.ContainingTypes.Length; i++)
            sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GetTypeDeclaration(INamedTypeSymbol symbol)
    {
        var keyword = symbol.IsRecord switch
        {
            true => symbol.IsValueType ? "record struct" : "record",
            false => symbol.TypeKind switch
            {
                TypeKind.Struct => "struct",
                TypeKind.Interface => "interface",
                _ => "class"
            }
        };

        var modifiers = symbol.IsStatic ? "static partial" : "partial";
        var accessibility = GetAccessibility(symbol);

        return $"{accessibility} {modifiers} {keyword} {symbol.Name}";
    }

    private static string GetAccessibility(INamedTypeSymbol symbol)
    {
        return symbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.Private => "private",
            Accessibility.ProtectedAndInternal => "private protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            _ => "private"
        };
    }

    private static string GetSafeFileName(string fullName)
    {
        return fullName
            .Replace("<", "_")
            .Replace(">", "_")
            .Replace(",", "_")
            .Replace(" ", string.Empty)
            .Replace(".", "_");
    }

    private readonly record struct CommandInfo(
        string? Namespace,
        ImmutableArray<string> ContainingTypes,
        string CommandTypeFullName,
        string CommandText,
        bool UseStoredProcedure);
}
